<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Easy Learning</title>
  <!-- Fonts & Icons -->
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
  <!-- GSAP for animations -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
  <style>
    :root {
      --bg-color: #0a0b14;
      --card-bg: rgba(22, 24, 37, 0.9);
      --text-color: #e2e8f0;
      --accent-color: #64ffda;
      --secondary-text: #94a3b8;
    }
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'JetBrains Mono', monospace;
    }
    body {
      background-color: var(--bg-color);
      color: var(--text-color);
      overflow: hidden;
    }
    header {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      padding: 10px 20px;
      background: var(--card-bg);
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 1001;
      border-bottom: 1px solid rgba(100, 255, 218, 0.2);
    }
    .logo {
      font-size: 1.5rem;
      font-weight: 600;
      color: var(--accent-color);
    }
    .nav-controls {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    .nav-controls input[type="text"] {
      padding: 5px 10px;
      border-radius: 6px;
      border: none;
      outline: none;
    }
    .nav-controls button {
      background: var(--accent-color);
      border: none;
      padding: 5px 10px;
      border-radius: 6px;
      cursor: pointer;
      color: var(--bg-color);
      font-weight: 600;
    }
    .bookmark-btn {
      background: transparent;
      border: none;
      color: var(--accent-color);
      font-size: 1.2rem;
      cursor: pointer;
    }
    .progress {
      font-size: 0.9rem;
      color: var(--secondary-text);
    }
    .container {
      position: absolute;
      top: 60px;
      bottom: 0;
      left: 0;
      right: 0;
      overflow-y: scroll;
      scroll-snap-type: y mandatory;
      padding-top: 20px;
    }
    .card {
      height: calc(100vh - 80px);
      scroll-snap-align: start;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 1rem;
    }
    .card-content {
      background: var(--card-bg);
      padding: 1.5rem;
      border-radius: 12px;
      border: 1px solid rgba(100, 255, 218, 0.1);
      width: 100%;
      max-width: 700px;
      margin: 0 1rem;
      backdrop-filter: blur(10px);
      opacity: 0;
      transform: translateY(20px);
      transition: all 0.3s ease;
      position: relative;
    }
    .card.active .card-content {
      opacity: 1;
      transform: translateY(0);
    }
    .title {
      font-size: 2rem;
      color: var(--accent-color);
      margin-bottom: 1rem;
      text-align: center;
    }
    .explanation {
      font-size: 1rem;
      line-height: 1.6;
      text-align: justify;
      margin-bottom: 1.5rem;
    }
    .card-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .card-footer a {
      text-decoration: none;
      color: var(--accent-color);
      font-weight: 600;
    }
    /* Bookmark Panel */
    .bookmark-panel {
      position: fixed;
      top: 60px;
      right: 0;
      width: 300px;
      max-height: 80vh;
      background: var(--card-bg);
      border-left: 1px solid rgba(100, 255, 218, 0.2);
      overflow-y: auto;
      padding: 10px;
      z-index: 1002;
      transform: translateX(100%);
      transition: transform 0.3s ease;
    }
    .bookmark-panel.show {
      transform: translateX(0);
    }
    .bookmark-panel h3 {
      color: var(--accent-color);
      margin-bottom: 10px;
      text-align: center;
    }
    .bookmark-item {
      padding: 8px;
      border-bottom: 1px solid rgba(100, 255, 218, 0.2);
      cursor: pointer;
    }
    /* Responsive adjustments */
    @media (max-width: 768px) {
      .title { font-size: 1.75rem; }
      .explanation { font-size: 0.95rem; }
      .bookmark-panel { width: 80%; }
    }
  </style>
</head>
<body>
  <header>
    <div class="logo">Easy Learning</div>
    <div class="nav-controls">
      <input type="text" id="searchInput" placeholder="Search concepts...">
      <button id="prevBtn"><i class="fas fa-chevron-up"></i> Prev</button>
      <button id="nextBtn">Next <i class="fas fa-chevron-down"></i></button>
      <div class="progress" id="progressIndicator"></div>
      <button id="toggleBookmarks" class="bookmark-btn"><i class="fas fa-bookmark"></i></button>
    </div>
  </header>
  <div class="bookmark-panel" id="bookmarkPanel">
    <h3>Bookmarked Concepts</h3>
    <div id="bookmarkList"></div>
  </div>
  <div class="container" id="container">
    <!-- Cards will be dynamically loaded here -->
  </div>

  <script>
    // ===============================
    // Expanded Concept Data (Multiple CS subjects)
    // ===============================
    const conceptsData = [
  {
    title: "Data Structures",
    explanation:
      "Data structures are methods for organizing data efficiently. They include arrays, linked lists, stacks, queues, trees, and graphs. Choosing the right structure is essential for optimizing algorithms and ensuring smooth data operations in software applications."
  },
  {
    title: "Algorithms",
    explanation:
      "Algorithms are well-defined procedures for solving problems. They underpin tasks such as searching, sorting, and optimization. Their performance is measured by time and space complexity, making them critical for efficient software design."
  },
  {
    title: "Operating Systems",
    explanation:
      "Operating systems manage computer hardware and software resources. They coordinate processes, handle memory management, and maintain file systems. Popular examples include Windows, Linux, and macOS, all of which provide the foundation for application execution."
  },
  {
    title: "Object-Oriented Programming (OOP)",
    explanation:
      "OOP organizes software design around data, or objects, rather than functions. Its key principles—encapsulation, inheritance, polymorphism, and abstraction—enable developers to create modular and reusable code."
  },
  {
    title: "Networking",
    explanation:
      "Networking connects computers to share data and resources. Fundamental concepts include IP addressing, protocols, routers, and switches. A solid grasp of networking principles is essential for designing secure and efficient communication systems."
  },
  {
    title: "Databases",
    explanation:
      "Databases store and manage data for applications. They can be relational (SQL) or non-relational (NoSQL). Effective database design is critical for ensuring data integrity, quick access, and scalability."
  },
  {
    title: "Cybersecurity",
    explanation:
      "Cybersecurity protects systems, networks, and data from digital attacks. It encompasses encryption, threat detection, and risk management, which are vital for safeguarding sensitive information in an increasingly connected world."
  },
  {
    title: "Cloud Computing",
    explanation:
      "Cloud computing provides on-demand computing resources over the internet. It offers scalability, cost efficiency, and flexibility through services like storage, servers, and applications, as offered by AWS, Azure, and Google Cloud."
  },
  {
    title: "Machine Learning",
    explanation:
      "Machine learning is a branch of AI that develops algorithms to learn from data. It enables pattern recognition, predictions, and automation in fields like image processing and natural language processing."
  },
  {
    title: "DevOps",
    explanation:
      "DevOps integrates development and IT operations to streamline software delivery. It emphasizes automation, continuous integration, and continuous deployment, ensuring faster releases and stable production environments."
  },
  {
    title: "Software Engineering",
    explanation:
      "Software engineering applies engineering principles to software development. It covers planning, designing, coding, testing, and maintenance to create robust, scalable, and efficient software systems."
  },
  {
    title: "Artificial Intelligence (AI)",
    explanation:
      "AI simulates human intelligence in machines through learning, reasoning, and self-correction. It encompasses machine learning, natural language processing, and robotics, driving innovations in many industries."
  },
  {
    title: "Blockchain",
    explanation:
      "Blockchain is a decentralized ledger that records transactions securely and transparently. Originally created for cryptocurrencies, its applications now extend to supply chain, voting systems, and secure data management."
  },
  {
    title: "Internet of Things (IoT)",
    explanation:
      "IoT connects everyday devices to the internet, enabling data exchange and automation. From smart homes to industrial sensors, IoT enhances efficiency and provides real-time insights into system performance."
  },
  {
    title: "Big Data Analytics",
    explanation:
      "Big Data Analytics involves examining large datasets to uncover patterns, trends, and insights. Using techniques such as data mining and machine learning, it empowers businesses to make informed, data-driven decisions."
  },
  {
    title: "Theory of Computation",
    explanation:
      "Theory of Computation explores the fundamental capabilities and limitations of computers. It involves studying models like Turing machines and complexity classes to understand what problems can be solved algorithmically."
  },
  {
    title: "Programming Languages",
    explanation:
      "Programming languages provide the syntax and semantics for writing software. They range from low-level languages like C to high-level languages like Python, each suited for different types of applications and performance requirements."
  },
  {
    title: "Compilers",
    explanation:
      "Compilers translate high-level programming languages into machine code that computers can execute. They optimize code for performance and detect errors, serving as a critical bridge between human-readable code and binary instructions."
  },
  {
    title: "Distributed Systems",
    explanation:
      "Distributed systems consist of multiple computers working together to achieve a common goal. They ensure reliability, scalability, and fault tolerance by distributing workloads and data across networked machines."
  },
  {
    title: "Human-Computer Interaction (HCI)",
    explanation:
      "HCI studies how people interact with computers and designs user-friendly interfaces. It focuses on usability, accessibility, and user experience to make technology more intuitive and efficient."
  },
  {
    title: "Information Retrieval",
    explanation:
      "Information retrieval involves finding and organizing relevant information from large datasets. It is the backbone of search engines and recommendation systems, relying on indexing, ranking, and natural language processing."
  },
  {
    title: "Computer Graphics",
    explanation:
      "Computer graphics create and manipulate visual content using algorithms. It encompasses rendering, modeling, and animation, and is essential for video games, simulations, and user interface design."
  },
  {
    title: "Mobile Computing",
    explanation:
      "Mobile computing enables data processing on portable devices such as smartphones and tablets. It involves optimizing applications for performance, connectivity, and user experience in dynamic, on-the-go environments."
  },
  {
    title: "Parallel Computing",
    explanation:
      "Parallel computing breaks down large problems into smaller tasks that are processed simultaneously. This approach leverages multi-core processors and distributed systems to significantly reduce computation time."
  },
  {
    title: "Quantum Computing",
    explanation:
      "Quantum computing uses quantum-mechanical phenomena to process information. It promises to solve certain complex problems much faster than classical computers by leveraging superposition and entanglement."
  },
  // Additional 225 concepts below
  {
    title: "Arrays",
    explanation:
      "Arrays are fundamental data structures that store elements in contiguous memory locations, enabling efficient access via indices."
  },
  {
    title: "Linked Lists",
    explanation:
      "Linked lists are linear data structures where elements are stored in nodes that contain a reference to the next node, allowing dynamic memory allocation."
  },
  {
    title: "Stacks",
    explanation:
      "Stacks are data structures that follow the Last In, First Out (LIFO) principle, used in scenarios like function calls and expression evaluation."
  },
  {
    title: "Queues",
    explanation:
      "Queues are data structures that follow the First In, First Out (FIFO) principle, essential for scheduling tasks and managing resources."
  },
  {
    title: "Trees",
    explanation:
      "Trees are hierarchical data structures consisting of nodes connected by edges, widely used in organizing data and facilitating fast search operations."
  },
  {
    title: "Graphs",
    explanation:
      "Graphs consist of nodes (vertices) and edges, representing relationships between objects and used in modeling networks and connections."
  },
  {
    title: "Heaps",
    explanation:
      "Heaps are specialized tree-based data structures that satisfy the heap property, making them ideal for implementing priority queues."
  },
  {
    title: "Hash Tables",
    explanation:
      "Hash tables store key-value pairs using a hash function to compute an index, allowing near constant-time data retrieval."
  },
  {
    title: "Tries",
    explanation:
      "Tries are tree-like data structures that store associative data, commonly used for efficient retrieval of strings."
  },
  {
    title: "Segment Trees",
    explanation:
      "Segment trees are advanced data structures used for storing information about intervals, allowing efficient range queries and updates."
  },
  {
    title: "Fenwick Trees",
    explanation:
      "Fenwick trees, or Binary Indexed Trees, provide efficient methods for cumulative frequency queries in a compact form."
  },
  {
    title: "Disjoint Set Union",
    explanation:
      "Disjoint Set Union (Union-Find) tracks elements partitioned into disjoint subsets, crucial for algorithms like Kruskal's for minimum spanning trees."
  },
  {
    title: "AVL Trees",
    explanation:
      "AVL Trees are self-balancing binary search trees that maintain height balance to ensure logarithmic time operations for insertion, deletion, and search."
  },
  {
    title: "Red-Black Trees",
    explanation:
      "Red-Black Trees are balanced binary search trees that use node coloring to maintain balance, ensuring efficient data operations."
  },
  {
    title: "B-Trees",
    explanation:
      "B-Trees are self-balancing trees optimized for systems that read and write large blocks of data, widely used in databases and file systems."
  },
  {
    title: "Splay Trees",
    explanation:
      "Splay trees are self-adjusting binary search trees that move frequently accessed elements nearer to the root, enhancing access times for repeated operations."
  },
  {
    title: "Skip Lists",
    explanation:
      "Skip lists are probabilistic data structures that enable fast search within an ordered sequence of elements, serving as an alternative to balanced trees."
  },
  {
    title: "Circular Linked Lists",
    explanation:
      "Circular linked lists are variations of linked lists where the last node points back to the first, allowing for continuous traversal."
  },
  {
    title: "Doubly Linked Lists",
    explanation:
      "Doubly linked lists enable traversal in both directions by having nodes with references to both the next and previous elements."
  },
  {
    title: "Binary Search Trees",
    explanation:
      "Binary Search Trees (BSTs) organize data hierarchically, enabling efficient searching, insertion, and deletion when the tree is balanced."
  },
  {
    title: "Multidimensional Arrays",
    explanation:
      "Multidimensional arrays extend the concept of arrays to multiple dimensions, useful for representing matrices and grids."
  },
  {
    title: "Sparse Matrices",
    explanation:
      "Sparse matrices predominantly contain zero values and are stored efficiently by recording only non-zero elements."
  },
  {
    title: "Matrix Operations",
    explanation:
      "Matrix operations, including addition, multiplication, and inversion, are fundamental in areas such as graphics, simulations, and machine learning."
  },
  {
    title: "Graph Traversal (DFS)",
    explanation:
      "Depth-First Search (DFS) is a graph traversal technique that explores as far as possible along each branch before backtracking."
  },
  {
    title: "Graph Traversal (BFS)",
    explanation:
      "Breadth-First Search (BFS) explores all neighbors of a node before moving to the next level, ideal for finding the shortest path in unweighted graphs."
  },
  {
    title: "Binary Search Algorithm",
    explanation:
      "Binary search efficiently locates an element in a sorted array by repeatedly dividing the search interval in half."
  },
  {
    title: "Linear Search",
    explanation:
      "Linear search sequentially checks each element of a list until a match is found, suitable for small or unsorted datasets."
  },
  {
    title: "Bubble Sort",
    explanation:
      "Bubble sort is a simple sorting algorithm that repeatedly swaps adjacent elements if they are in the wrong order, though it is inefficient for large arrays."
  },
  {
    title: "Selection Sort",
    explanation:
      "Selection sort repeatedly selects the smallest (or largest) element from the unsorted portion and places it at the beginning, performing in-place sorting."
  },
  {
    title: "Insertion Sort",
    explanation:
      "Insertion sort builds the final sorted array one item at a time by inserting elements into their correct position, effective for small datasets."
  },
  {
    title: "Merge Sort",
    explanation:
      "Merge sort is a divide and conquer algorithm that splits an array into halves, recursively sorts them, and then merges the sorted halves."
  },
  {
    title: "Quick Sort",
    explanation:
      "Quick sort selects a pivot element and partitions the array around it, recursively sorting the subarrays for efficient average-case performance."
  },
  {
    title: "Heap Sort",
    explanation:
      "Heap sort uses a heap data structure to repeatedly extract the maximum or minimum element, sorting the array in place with good worst-case performance."
  },
  {
    title: "Counting Sort",
    explanation:
      "Counting sort is a non-comparison sorting algorithm that counts the occurrences of each unique element, ideal for sorting integers within a specific range."
  },
  {
    title: "Radix Sort",
    explanation:
      "Radix sort processes numbers digit by digit, grouping them by individual digits to achieve efficient sorting without direct comparisons."
  },
  {
    title: "Shell Sort",
    explanation:
      "Shell sort is an optimized version of insertion sort that allows the exchange of items far apart, reducing the total number of shifts required."
  },
  {
    title: "Bucket Sort",
    explanation:
      "Bucket sort distributes elements into several buckets and then individually sorts these buckets, often combining with another sorting algorithm."
  },
  {
    title: "Tim Sort",
    explanation:
      "Tim sort is a hybrid stable sorting algorithm derived from merge sort and insertion sort, optimized for real-world data and used in many programming languages."
  },
  {
    title: "Backtracking Algorithms",
    explanation:
      "Backtracking systematically searches for a solution by trying out possible options and abandoning them if they fail to satisfy constraints."
  },
  {
    title: "Dynamic Programming",
    explanation:
      "Dynamic programming breaks problems into overlapping subproblems, solving each just once and storing their solutions to avoid redundant computations."
  },
  {
    title: "Greedy Algorithms",
    explanation:
      "Greedy algorithms make the locally optimal choice at each step with the hope of finding the global optimum, often used in optimization problems."
  },
  {
    title: "Divide and Conquer",
    explanation:
      "Divide and conquer algorithms split a problem into smaller subproblems, solve them independently, and then combine their solutions to solve the original problem."
  },
  {
    title: "Recursion",
    explanation:
      "Recursion is a programming technique where a function calls itself to solve a smaller instance of the same problem until reaching a base case."
  },
  {
    title: "Memoization",
    explanation:
      "Memoization is an optimization technique that stores the results of expensive function calls and reuses them when the same inputs occur again."
  },
  {
    title: "Tabulation",
    explanation:
      "Tabulation is a bottom-up dynamic programming approach where solutions to subproblems are iteratively computed and stored in a table."
  },
  {
    title: "String Matching Algorithms (KMP)",
    explanation:
      "The Knuth-Morris-Pratt (KMP) algorithm efficiently searches for a substring within a text by preprocessing the pattern to avoid redundant comparisons."
  },
  {
    title: "String Matching Algorithms (Rabin-Karp)",
    explanation:
      "The Rabin-Karp algorithm uses hashing to find any one of a set of pattern strings in a text, making it effective for multiple pattern searches."
  },
  {
    title: "String Matching Algorithms (Boyer-Moore)",
    explanation:
      "The Boyer-Moore algorithm improves string search efficiency by using information gained during the scan to skip sections of the text."
  },
  {
    title: "Pattern Searching in Strings",
    explanation:
      "Pattern searching involves identifying and locating sequences of characters within a larger text, essential in text processing and search engines."
  },
  {
    title: "Suffix Trees",
    explanation:
      "Suffix trees are data structures that store all suffixes of a string, enabling fast pattern matching and other string-related queries."
  },
  {
    title: "Suffix Arrays",
    explanation:
      "Suffix arrays are space-efficient alternatives to suffix trees that store sorted indices of all suffixes, useful in full-text searches."
  },
  {
    title: "Bit Manipulation",
    explanation:
      "Bit manipulation involves algorithmic techniques that operate directly on bits, enabling efficient solutions for low-level operations and optimizations."
  },
  {
    title: "Permutations and Combinations Algorithms",
    explanation:
      "These algorithms generate all possible arrangements or selections of a set of elements, essential for solving combinatorial problems."
  },
  {
    title: "Graph Algorithms (Dijkstra's)",
    explanation:
      "Dijkstra's algorithm finds the shortest path between nodes in a weighted graph with non-negative weights, widely used in navigation systems."
  },
  {
    title: "Graph Algorithms (Bellman-Ford)",
    explanation:
      "The Bellman-Ford algorithm computes shortest paths in graphs that may contain negative weight edges, while also detecting negative cycles."
  },
  {
    title: "Graph Algorithms (Floyd-Warshall)",
    explanation:
      "The Floyd-Warshall algorithm computes shortest paths between all pairs of vertices in a weighted graph using dynamic programming."
  },
  {
    title: "Minimum Spanning Trees (Kruskal's)",
    explanation:
      "Kruskal's algorithm finds a minimum spanning tree by sorting all the edges and adding them one by one while avoiding cycles."
  },
  {
    title: "Minimum Spanning Trees (Prim's)",
    explanation:
      "Prim's algorithm builds a minimum spanning tree by starting from an arbitrary node and repeatedly adding the smallest edge that expands the tree."
  },
  {
    title: "Network Flow Algorithms (Ford-Fulkerson)",
    explanation:
      "The Ford-Fulkerson method computes the maximum flow in a network by finding augmenting paths and increasing the flow until no more exist."
  },
  {
    title: "Network Flow Algorithms (Edmonds-Karp)",
    explanation:
      "Edmonds-Karp is an implementation of Ford-Fulkerson using breadth-first search to find the shortest augmenting paths, ensuring polynomial time complexity."
  },
  {
    title: "Topological Sorting",
    explanation:
      "Topological sorting orders the vertices of a directed acyclic graph such that every directed edge from vertex A to vertex B implies that A comes before B."
  },
  {
    title: "Strongly Connected Components (Kosaraju's)",
    explanation:
      "Kosaraju's algorithm identifies strongly connected components in a directed graph using two passes of depth-first search."
  },
  {
    title: "Strongly Connected Components (Tarjan's)",
    explanation:
      "Tarjan's algorithm finds strongly connected components in a graph in a single DFS pass using low-link values, making it highly efficient."
  },
  {
    title: "Computational Geometry (Convex Hull)",
    explanation:
      "Convex hull algorithms determine the smallest convex polygon that encloses a set of points, a fundamental problem in computational geometry."
  },
  {
    title: "Computational Geometry (Line Intersection)",
    explanation:
      "Line intersection algorithms detect whether and where lines intersect, essential for computer graphics and spatial analysis."
  },
  {
    title: "Computational Geometry (Closest Pair of Points)",
    explanation:
      "The closest pair algorithm identifies the two nearest points in a set, optimizing search using divide and conquer techniques."
  },
  {
    title: "Matrix Multiplication Algorithms",
    explanation:
      "Matrix multiplication algorithms compute the product of two matrices, with techniques like Strassen's algorithm reducing the number of multiplications required."
  },
  {
    title: "Strassen's Algorithm",
    explanation:
      "Strassen's algorithm is an efficient matrix multiplication method that reduces the overall complexity compared to the conventional approach."
  },
  {
    title: "Fast Fourier Transform (FFT)",
    explanation:
      "FFT efficiently computes the Discrete Fourier Transform, crucial for signal processing, image analysis, and solving differential equations."
  },
  {
    title: "Backpropagation in Neural Networks",
    explanation:
      "Backpropagation is the key algorithm for training neural networks by propagating errors backward and adjusting weights iteratively."
  },
  {
    title: "Convolutional Neural Networks (CNN)",
    explanation:
      "CNNs are deep learning models specialized for processing grid-like data such as images, utilizing convolutional layers to extract features."
  },
  {
    title: "Recurrent Neural Networks (RNN)",
    explanation:
      "RNNs are designed for sequential data processing, where outputs from previous steps are fed as inputs to influence future predictions."
  },
  {
    title: "Long Short-Term Memory (LSTM)",
    explanation:
      "LSTM networks are a type of RNN that overcome the vanishing gradient problem, enabling the modeling of long-term dependencies in sequences."
  },
  {
    title: "Generative Adversarial Networks (GANs)",
    explanation:
      "GANs consist of two neural networks—the generator and discriminator—that compete to produce realistic synthetic data."
  },
  {
    title: "Reinforcement Learning",
    explanation:
      "Reinforcement learning involves agents learning to make decisions by receiving rewards or penalties, optimizing behavior over time."
  },
  {
    title: "Supervised Learning",
    explanation:
      "Supervised learning trains models on labeled datasets to predict outputs for new inputs, forming the basis of many machine learning applications."
  },
  {
    title: "Unsupervised Learning",
    explanation:
      "Unsupervised learning explores data without labeled responses, finding hidden patterns or groupings within the data."
  },
  {
    title: "Semi-Supervised Learning",
    explanation:
      "Semi-supervised learning combines a small amount of labeled data with a large amount of unlabeled data to improve learning accuracy."
  },
  {
    title: "Transfer Learning",
    explanation:
      "Transfer learning leverages a pre-trained model on a related task to reduce the need for large datasets and lengthy training times."
  },
  {
    title: "Dimensionality Reduction (PCA)",
    explanation:
      "Principal Component Analysis (PCA) reduces the dimensionality of data by transforming it into principal components that capture the most variance."
  },
  {
    title: "Dimensionality Reduction (t-SNE)",
    explanation:
      "t-SNE is a nonlinear dimensionality reduction technique used for visualizing high-dimensional data in two or three dimensions."
  },
  {
    title: "Clustering Algorithms (K-Means)",
    explanation:
      "K-Means clustering partitions data into a specified number of clusters by iteratively assigning data points and updating cluster centroids."
  },
  {
    title: "Clustering Algorithms (Hierarchical Clustering)",
    explanation:
      "Hierarchical clustering builds nested clusters either from the bottom up or top down, without needing to specify the number of clusters in advance."
  },
  {
    title: "Decision Trees in Machine Learning",
    explanation:
      "Decision trees split data based on feature values to create a tree-like model, used for both classification and regression tasks."
  },
  {
    title: "Random Forests",
    explanation:
      "Random forests combine multiple decision trees to improve prediction accuracy and reduce overfitting, forming a robust ensemble model."
  },
  {
    title: "Support Vector Machines (SVM)",
    explanation:
      "SVMs are supervised learning models that find the optimal hyperplane to separate data into distinct classes with maximum margin."
  },
  {
    title: "Ensemble Methods (Boosting)",
    explanation:
      "Boosting sequentially combines weak learners to form a strong overall model, focusing on misclassified examples to improve performance."
  },
  {
    title: "Ensemble Methods (Bagging)",
    explanation:
      "Bagging aggregates predictions from multiple models trained on random subsets of data, reducing variance and improving robustness."
  },
  {
    title: "Natural Language Processing (NLP)",
    explanation:
      "NLP enables computers to understand, interpret, and generate human language, powering applications like translation and sentiment analysis."
  },
  {
    title: "Sentiment Analysis",
    explanation:
      "Sentiment analysis uses NLP techniques to determine the emotional tone behind text, useful for market research and social media monitoring."
  },
  {
    title: "Text Classification",
    explanation:
      "Text classification categorizes text into predefined groups using machine learning and NLP techniques, aiding in organization and analysis."
  },
  {
    title: "Speech Recognition",
    explanation:
      "Speech recognition converts spoken language into text through signal processing and machine learning, enabling voice-controlled applications."
  },
  {
    title: "Computer Vision",
    explanation:
      "Computer vision enables machines to interpret visual data from the world, powering applications like facial recognition and autonomous vehicles."
  },
  {
    title: "Object Detection",
    explanation:
      "Object detection identifies and locates objects within images or videos, often using deep learning models like CNNs to perform real-time analysis."
  },
  {
    title: "Image Segmentation",
    explanation:
      "Image segmentation divides an image into meaningful segments, aiding in tasks such as object recognition and scene understanding."
  },
  {
    title: "Augmented Reality",
    explanation:
      "Augmented reality overlays digital content onto the real world, enhancing user experiences in applications like gaming, education, and navigation."
  },
  {
    title: "Virtual Reality",
    explanation:
      "Virtual reality immerses users in a completely digital environment, often using headsets and motion controllers to simulate real-world experiences."
  },
  {
    title: "Robotics in Computer Science",
    explanation:
      "Robotics integrates computing with mechanical systems to design and program robots, involving sensors, control systems, and artificial intelligence."
  },
  {
    title: "Internet Protocols (TCP/IP)",
    explanation:
      "TCP/IP protocols form the foundation of internet communication, outlining how data is packetized, transmitted, and received over networks."
  },
  {
    title: "Network Address Translation (NAT)",
    explanation:
      "NAT translates private IP addresses to a public IP address, allowing multiple devices to share a single internet connection securely."
  },
  {
    title: "Domain Name System (DNS)",
    explanation:
      "DNS translates human-readable domain names into IP addresses, acting as the internet's directory to locate websites and services."
  },
  {
    title: "Hypertext Transfer Protocol (HTTP)",
    explanation:
      "HTTP is the protocol for transferring web pages and data on the internet, enabling communication between web servers and clients."
  },
  {
    title: "Secure Sockets Layer (SSL)/TLS",
    explanation:
      "SSL/TLS protocols encrypt data transmitted over the internet, ensuring secure communication between clients and servers."
  },
  {
    title: "RESTful API Design",
    explanation:
      "RESTful APIs adhere to REST principles to create scalable, stateless web services that enable communication between client and server."
  },
  {
    title: "GraphQL APIs",
    explanation:
      "GraphQL is a query language for APIs that allows clients to request exactly the data they need, optimizing data retrieval and reducing over-fetching."
  },
  {
    title: "Microservices Architecture",
    explanation:
      "Microservices architecture breaks down applications into small, independent services that communicate over networks, enhancing scalability and maintainability."
  },
  {
    title: "Containerization (Docker)",
    explanation:
      "Docker containerizes applications along with their dependencies, ensuring consistent environments across development, testing, and production."
  },
  {
    title: "Container Orchestration (Kubernetes)",
    explanation:
      "Kubernetes automates the deployment, scaling, and management of containerized applications, streamlining operations in distributed systems."
  },
  {
    title: "Virtualization Technologies",
    explanation:
      "Virtualization allows multiple virtual machines to run on a single physical host, optimizing resource utilization and isolation."
  },
  {
    title: "Edge Computing",
    explanation:
      "Edge computing processes data near its source rather than in a centralized data center, reducing latency and bandwidth usage."
  },
  {
    title: "Serverless Computing",
    explanation:
      "Serverless computing abstracts server management, allowing developers to focus solely on writing code without handling infrastructure details."
  },
  {
    title: "Fog Computing",
    explanation:
      "Fog computing extends cloud services to the network edge, providing low-latency processing and localized data management."
  },
  {
    title: "Internet Security Protocols",
    explanation:
      "Internet security protocols protect data transmission over networks through encryption, authentication, and secure key exchange."
  },
  {
    title: "Cryptography Fundamentals",
    explanation:
      "Cryptography encompasses methods for secure communication through encryption and decryption, ensuring data privacy and integrity."
  },
  {
    title: "Symmetric Encryption",
    explanation:
      "Symmetric encryption uses the same key for both encryption and decryption, offering fast and efficient data protection when managed securely."
  },
  {
    title: "Asymmetric Encryption",
    explanation:
      "Asymmetric encryption uses a pair of keys (public and private) to secure data, facilitating secure communications and digital signatures."
  },
  {
    title: "Hash Functions",
    explanation:
      "Hash functions convert input data into fixed-size hash values, playing a crucial role in data integrity checks and efficient data retrieval."
  },
  {
    title: "Digital Signatures",
    explanation:
      "Digital signatures authenticate the source of a message and ensure its integrity using cryptographic techniques, essential for secure communications."
  },
  {
    title: "Public Key Infrastructure (PKI)",
    explanation:
      "PKI manages digital certificates and public-key encryption, establishing trust and secure communications in digital transactions."
  },
  {
    title: "Blockchain Consensus Mechanisms",
    explanation:
      "Consensus mechanisms in blockchain, such as Proof of Work and Proof of Stake, ensure all participants agree on the network state."
  },
  {
    title: "Smart Contracts",
    explanation:
      "Smart contracts are self-executing contracts with terms written in code, enabling automated, trustless transactions on blockchain platforms."
  },
  {
    title: "Cryptocurrency Fundamentals",
    explanation:
      "Cryptocurrency fundamentals cover the principles behind digital currencies, including decentralization, blockchain technology, and mining."
  },
  {
    title: "Software Testing (Unit Testing)",
    explanation:
      "Unit testing involves testing individual components or functions in isolation to verify that each part performs as expected."
  },
  {
    title: "Software Testing (Integration Testing)",
    explanation:
      "Integration testing verifies that different modules or services work together correctly after unit testing has been completed."
  },
  {
    title: "Software Testing (System Testing)",
    explanation:
      "System testing evaluates the complete integrated system to ensure it meets the specified requirements and functions as intended."
  },
  {
    title: "Test-Driven Development (TDD)",
    explanation:
      "TDD is a development process where tests are written before code, guiding design and ensuring that each feature works correctly from the start."
  },
  {
    title: "Behavior-Driven Development (BDD)",
    explanation:
      "BDD extends TDD by using natural language descriptions of software behavior, fostering better collaboration between technical and non-technical team members."
  },
  {
    title: "Continuous Integration (CI)",
    explanation:
      "Continuous Integration is the practice of automatically building and testing code changes as they are integrated, ensuring early detection of integration issues."
  },
  {
    title: "Continuous Deployment (CD)",
    explanation:
      "Continuous Deployment automates the release of software changes to production, ensuring that updates are delivered quickly and reliably."
  },
  {
    title: "Version Control Systems (Git)",
    explanation:
      "Git is a distributed version control system that tracks changes in source code, enabling collaboration, branching, and rollback capabilities."
  },
  {
    title: "Code Review Practices",
    explanation:
      "Code reviews involve systematically examining source code to identify errors, ensure adherence to coding standards, and facilitate knowledge sharing."
  },
  {
    title: "Agile Methodologies (Scrum)",
    explanation:
      "Scrum is an agile framework that uses iterative cycles called sprints to deliver incremental improvements and maintain flexibility in software development."
  },
  {
    title: "Agile Methodologies (Kanban)",
    explanation:
      "Kanban is an agile method that visualizes work in progress on boards, enabling teams to manage tasks and optimize workflow continuously."
  },
  {
    title: "Waterfall Model in Software Development",
    explanation:
      "The Waterfall model is a linear, sequential approach to software development where each phase must be completed before the next begins."
  },
  {
    title: "Extreme Programming (XP)",
    explanation:
      "Extreme Programming is an agile methodology that emphasizes customer satisfaction, frequent releases, and continuous feedback to improve software quality."
  },
  {
    title: "Software Documentation Best Practices",
    explanation:
      "Effective software documentation clearly communicates design decisions, usage instructions, and maintenance guidelines, ensuring long-term project success."
  },
  {
    title: "Debugging Techniques",
    explanation:
      "Debugging techniques involve systematically identifying, isolating, and fixing bugs in software to improve stability and performance."
  },
  {
    title: "Profiling and Performance Tuning",
    explanation:
      "Profiling analyzes program execution to identify performance bottlenecks, while tuning optimizes resource usage and execution speed."
  },
  {
    title: "Memory Management in Programming",
    explanation:
      "Memory management involves the efficient allocation, usage, and deallocation of memory resources, critical for ensuring optimal application performance."
  },
  {
    title: "Garbage Collection Mechanisms",
    explanation:
      "Garbage collection automates memory management by reclaiming unused memory, reducing the likelihood of memory leaks and programming errors."
  },
  {
    title: "Concurrency in Programming",
    explanation:
      "Concurrency enables multiple processes or threads to execute simultaneously, improving performance and resource utilization on multi-core systems."
  },
  {
    title: "Multithreading Concepts",
    explanation:
      "Multithreading allows a program to perform multiple tasks concurrently within a single process, enhancing responsiveness and throughput."
  },
  {
    title: "Parallel Programming Paradigms",
    explanation:
      "Parallel programming involves techniques that allow simultaneous data processing across multiple computing cores or nodes to accelerate computation."
  },
  {
    title: "Asynchronous Programming",
    explanation:
      "Asynchronous programming enables non-blocking operations by allowing tasks to run concurrently, improving application responsiveness."
  },
  {
    title: "Event-Driven Programming",
    explanation:
      "Event-driven programming centers on responding to events or user actions, triggering specific functions or processes when those events occur."
  },
  {
    title: "Observer Pattern",
    explanation:
      "The Observer pattern establishes a subscription mechanism, allowing objects to be notified of changes in the state of other objects."
  },
  {
    title: "Singleton Pattern",
    explanation:
      "The Singleton pattern ensures that a class has only one instance and provides a global point of access to that instance."
  },
  {
    title: "Factory Pattern",
    explanation:
      "The Factory pattern abstracts the creation of objects, allowing subclasses to decide which class to instantiate without exposing the creation logic."
  },
  {
    title: "Abstract Factory Pattern",
    explanation:
      "The Abstract Factory pattern provides an interface for creating families of related objects without specifying their concrete classes."
  },
  {
    title: "Builder Pattern",
    explanation:
      "The Builder pattern separates the construction of a complex object from its representation, enabling step-by-step object creation."
  },
  {
    title: "Prototype Pattern",
    explanation:
      "The Prototype pattern creates new objects by cloning an existing instance, facilitating object creation in resource-intensive situations."
  },
  {
    title: "Adapter Pattern",
    explanation:
      "The Adapter pattern allows incompatible interfaces to work together by converting one interface into another expected by the client."
  },
  {
    title: "Bridge Pattern",
    explanation:
      "The Bridge pattern decouples an abstraction from its implementation so that the two can vary independently."
  },
  {
    title: "Composite Pattern",
    explanation:
      "The Composite pattern composes objects into tree structures to represent part-whole hierarchies, allowing clients to treat individual and composite objects uniformly."
  },
  {
    title: "Decorator Pattern",
    explanation:
      "The Decorator pattern dynamically adds responsibilities to objects without altering their structure, promoting flexible code extensions."
  },
  {
    title: "Facade Pattern",
    explanation:
      "The Facade pattern provides a simplified interface to a complex subsystem, reducing dependencies and easing usage."
  },
  {
    title: "Flyweight Pattern",
    explanation:
      "The Flyweight pattern minimizes memory usage by sharing common data among similar objects, especially when handling large numbers of objects."
  },
  {
    title: "Proxy Pattern",
    explanation:
      "The Proxy pattern provides a surrogate or placeholder for another object to control access, reduce cost, or add additional functionality."
  },
  {
    title: "Chain of Responsibility Pattern",
    explanation:
      "The Chain of Responsibility pattern passes a request along a chain of handlers until one of them handles it, promoting loose coupling."
  },
  {
    title: "Command Pattern",
    explanation:
      "The Command pattern encapsulates a request as an object, allowing parameterization of clients and queuing or logging of requests."
  },
  {
    title: "Interpreter Pattern",
    explanation:
      "The Interpreter pattern defines a grammatical representation for a language and provides an interpreter to process sentences in that language."
  },
  {
    title: "Iterator Pattern",
    explanation:
      "The Iterator pattern provides a way to access elements of a collection sequentially without exposing its underlying representation."
  },
  {
    title: "Mediator Pattern",
    explanation:
      "The Mediator pattern centralizes complex communications and control logic between related objects, reducing coupling."
  },
  {
    title: "Memento Pattern",
    explanation:
      "The Memento pattern captures an object's internal state so that it can be restored later, supporting undo functionality in applications."
  },
  {
    title: "State Pattern",
    explanation:
      "The State pattern allows an object to alter its behavior when its internal state changes, making it appear as if it changed its class."
  },
  {
    title: "Strategy Pattern",
    explanation:
      "The Strategy pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable to let the algorithm vary independently from clients."
  },
  {
    title: "Template Method Pattern",
    explanation:
      "The Template Method pattern defines the skeleton of an algorithm in a method, deferring some steps to subclasses for flexibility."
  },
  {
    title: "Visitor Pattern",
    explanation:
      "The Visitor pattern separates an algorithm from an object structure, allowing new operations to be defined without changing the classes of the elements on which it operates."
  },
  {
    title: "MVC Architecture (Model-View-Controller)",
    explanation:
      "MVC is an architectural pattern that separates an application into three main components—Model, View, and Controller—to promote organized and modular code."
  },
  {
    title: "MVVM Architecture (Model-View-ViewModel)",
    explanation:
      "MVVM separates the development of the graphical user interface from business logic by introducing a ViewModel that binds data between the Model and the View."
  },
  {
    title: "REST Architecture Principles",
    explanation:
      "REST principles guide the design of scalable and interoperable web services, emphasizing statelessness, resource-based interactions, and a uniform interface."
  },
  {
    title: "Microkernel Architecture",
    explanation:
      "Microkernel architecture structures a system with a minimal core and extendable modules, promoting flexibility and ease of maintenance."
  },
  {
    title: "Service-Oriented Architecture (SOA)",
    explanation:
      "SOA organizes software as a collection of services that communicate over a network, enabling reuse and interoperability across platforms."
  },
  {
    title: "Event Sourcing",
    explanation:
      "Event sourcing captures all changes to an application's state as a sequence of events, enabling auditability and the reconstruction of past states."
  },
  {
    title: "CQRS (Command Query Responsibility Segregation)",
    explanation:
      "CQRS separates read and write operations by using different models, optimizing performance, scalability, and security in complex systems."
  },
  {
    title: "Enterprise Integration Patterns",
    explanation:
      "Enterprise integration patterns provide proven solutions for integrating disparate systems and applications, facilitating smooth communication and data exchange."
  },
  {
    title: "Reactive Programming",
    explanation:
      "Reactive programming is an asynchronous paradigm that focuses on data streams and the propagation of change, enabling responsive and resilient systems."
  },
  {
    title: "Functional Programming Concepts",
    explanation:
      "Functional programming emphasizes immutability, pure functions, and first-class functions to produce more predictable and concise code."
  },
  {
    title: "Immutable Data Structures",
    explanation:
      "Immutable data structures cannot be modified after creation, reducing side effects and making concurrent programming safer."
  },
  {
    title: "Lambda Expressions in Programming",
    explanation:
      "Lambda expressions provide a concise syntax for writing anonymous functions, often used in functional programming for short-lived operations."
  },
  {
    title: "First-Class Functions",
    explanation:
      "First-class functions treat functions as values, allowing them to be passed as arguments, returned from other functions, or assigned to variables."
  },
  {
    title: "Higher-Order Functions",
    explanation:
      "Higher-order functions either take functions as parameters or return them, promoting modularity and code reuse in functional programming."
  },
  {
    title: "Closures in Programming",
    explanation:
      "Closures capture the lexical scope in which they are defined, allowing inner functions to access variables from their enclosing context even after that context has ended."
  },
  {
    title: "Recursion vs Iteration",
    explanation:
      "Recursion solves problems by calling a function within itself, while iteration repeatedly executes a block of code, each having its own advantages and trade-offs."
  },
  {
    title: "Object Serialization",
    explanation:
      "Object serialization converts objects into a format that can be stored or transmitted and later reconstructed, essential for data persistence and communication."
  },
  {
    title: "Dependency Injection",
    explanation:
      "Dependency injection is a design pattern that supplies an object with its dependencies from the outside, promoting decoupling and easier testing."
  },
  {
    title: "Inversion of Control (IoC)",
    explanation:
      "IoC is a design principle in which the control of object creation and dependency management is transferred to a container or framework, enhancing modularity."
  },
  {
    title: "Aspect-Oriented Programming (AOP)",
    explanation:
      "AOP separates cross-cutting concerns such as logging or security from the main business logic, allowing behavior to be added dynamically without modifying code."
  },
  {
    title: "Software Design Principles (SOLID)",
    explanation:
      "SOLID principles provide guidelines for designing maintainable and scalable object-oriented software by emphasizing single responsibility, open-closed, Liskov substitution, interface segregation, and dependency inversion."
  },
  {
    title: "DRY Principle (Don't Repeat Yourself)",
    explanation:
      "The DRY principle encourages minimizing repetition of code, promoting reusability and easier maintenance by avoiding duplicate logic."
  },
  {
    title: "KISS Principle (Keep It Simple, Stupid)",
    explanation:
      "The KISS principle advocates for simplicity in design and implementation, discouraging unnecessary complexity that can lead to maintenance challenges."
  },
  {
    title: "YAGNI Principle (You Aren't Gonna Need It)",
    explanation:
      "YAGNI advises developers to implement only what is necessary for the current requirements, avoiding over-engineering and wasted resources."
  },
  {
    title: "Code Smells and Refactoring",
    explanation:
      "Code smells are indicators of potential problems in code structure, while refactoring involves restructuring existing code to improve readability, maintainability, and performance."
  },
  {
    title: "Unit Testing Frameworks (JUnit, pytest)",
    explanation:
      "Unit testing frameworks provide tools and libraries to write and execute tests for individual components, ensuring that each unit functions correctly in isolation."
  },
  {
    title: "Behavior-Driven Development Tools (Cucumber)",
    explanation:
      "Tools like Cucumber facilitate BDD by allowing test scenarios to be written in plain language, bridging the gap between technical and non-technical team members."
  },
  {
    title: "Continuous Monitoring in DevOps",
    explanation:
      "Continuous monitoring involves real-time tracking of system performance and errors, enabling proactive issue detection and rapid remediation in production environments."
  },
  {
    title: "Infrastructure as Code (IaC)",
    explanation:
      "IaC uses code to automate the provisioning and management of infrastructure, ensuring consistency, reducing manual errors, and speeding up deployments."
  },
  {
    title: "Configuration Management Tools (Ansible, Puppet)",
    explanation:
      "Tools like Ansible and Puppet automate system configuration and application deployment, making environments reproducible and manageable."
  },
  {
    title: "Software Metrics and KPIs",
    explanation:
      "Software metrics and key performance indicators (KPIs) measure various aspects of software development and performance, guiding process improvements and decision-making."
  },
  {
    title: "Risk Management in Software Projects",
    explanation:
      "Risk management involves identifying, assessing, and mitigating potential risks throughout the software development lifecycle to ensure successful project outcomes."
  },
  {
    title: "Load Balancing Techniques",
    explanation:
      "Load balancing distributes workloads across multiple servers or resources to optimize resource use, maximize throughput, and ensure high availability."
  },
  {
    title: "Caching Strategies in Web Applications",
    explanation:
      "Caching strategies store frequently accessed data temporarily to reduce latency and improve the performance of web applications."
  },
  {
    title: "Content Delivery Networks (CDN)",
    explanation:
      "CDNs distribute web content across geographically dispersed servers to reduce latency, improve load times, and enhance user experience globally."
  },
  {
    title: "WebSockets in Real-Time Communication",
    explanation:
      "WebSockets provide a full-duplex communication channel over a single TCP connection, enabling real-time data exchange between clients and servers."
  },
  {
    title: "Single Page Applications (SPA)",
    explanation:
      "SPAs load a single HTML page and dynamically update content, resulting in faster interactions and a smoother user experience."
  },
  {
    title: "Progressive Web Apps (PWA)",
    explanation:
      "PWAs combine the best features of web and mobile applications, offering offline capabilities, improved performance, and enhanced user engagement."
  },
  {
    title: "Responsive Web Design Principles",
    explanation:
      "Responsive design ensures that web applications adapt seamlessly to various screen sizes and devices, providing an optimal viewing experience."
  },
  {
    title: "Cross-Browser Compatibility",
    explanation:
      "Ensuring cross-browser compatibility involves designing web applications that function correctly across different browsers and platforms."
  },
  {
    title: "Web Accessibility Standards (WCAG)",
    explanation:
      "WCAG guidelines define best practices to ensure that web content is accessible to all users, including those with disabilities."
  },
  {
    title: "User Experience (UX) Design",
    explanation:
      "UX design focuses on creating products that provide meaningful and relevant experiences to users, balancing usability, accessibility, and aesthetics."
  },
  {
    title: "User Interface (UI) Design Principles",
    explanation:
      "UI design principles guide the creation of intuitive and visually appealing interfaces that enhance user interaction and satisfaction."
  },
  {
    title: "Wireframing and Prototyping Tools",
    explanation:
      "Wireframing and prototyping tools allow designers to create and test mockups of user interfaces before development, streamlining the design process."
  },
  {
    title: "A/B Testing in Web Development",
    explanation:
      "A/B testing involves comparing two versions of a webpage or application to determine which performs better, informing data-driven design decisions."
  },
  {
    title: "Search Engine Optimization (SEO)",
    explanation:
      "SEO encompasses strategies to improve a website's visibility in search engine results, driving organic traffic and enhancing online presence."
  },
  {
    title: "Data Visualization Techniques",
    explanation:
      "Data visualization transforms complex data into graphical formats, making trends and insights more accessible and actionable."
  },
  {
    title: "Graph Databases",
    explanation:
      "Graph databases store data in nodes and edges, optimizing the representation and querying of complex relationships and interconnected data."
  },
  {
    title: "In-Memory Databases (Redis)",
    explanation:
      "In-memory databases like Redis store data in RAM for rapid access, making them ideal for caching and real-time applications."
  },
  {
    title: "Columnar Databases",
    explanation:
      "Columnar databases store data by columns rather than rows, significantly improving query performance in analytical workloads."
  },
  {
    title: "Time-Series Databases",
    explanation:
      "Time-series databases are optimized for handling time-stamped data, enabling efficient storage and querying of temporal information."
  },
  {
    title: "Data Warehousing Concepts",
    explanation:
      "Data warehousing involves consolidating large volumes of data from multiple sources into a centralized repository for analysis and reporting."
  },
  {
    title: "ETL (Extract, Transform, Load) Processes",
    explanation:
      "ETL processes extract data from various sources, transform it into a suitable format, and load it into databases or data warehouses for analysis."
  },
  {
    title: "Real-Time Data Processing",
    explanation:
      "Real-time data processing analyzes data as it is generated, enabling immediate insights and rapid responses in dynamic environments."
  },
  {
    title: "Event-Driven Architecture in Distributed Systems",
    explanation:
      "Event-driven architecture uses events to trigger and coordinate communication between decoupled services in distributed systems, enhancing scalability and responsiveness."
  },
  {
    title: "Computational Complexity",
    explanation:
      "Computational complexity studies the resources required for solving computational problems, categorizing them based on time, space, and other factors."
  },
  {
    title: "Approximation Algorithms",
    explanation:
      "Approximation algorithms provide near-optimal solutions for NP-hard problems when exact solutions are computationally infeasible, balancing accuracy and efficiency."
  }
];


    // ===============================
    // Global Variables
    // ===============================
    let currentIndex = 0;
    let filteredConcepts = [];
    let bookmarks = JSON.parse(localStorage.getItem('bookmarks')) || [];

    // ===============================
    // Utility: Shuffle Array (Fisher-Yates)
    // ===============================
    function shuffle(array) {
      let currentIndex = array.length, randomIndex;
      while (currentIndex !== 0) {
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex--;
        [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
      }
      return array;
    }

    // ===============================
    // Render the Concept Cards
    // ===============================
    function loadConcepts() {
      // On each load, shuffle the concepts and then use them
      filteredConcepts = shuffle(conceptsData.slice());
      currentIndex = 0;
      const container = document.getElementById('container');
      container.innerHTML = '';
      filteredConcepts.forEach((concept, index) => {
        const card = document.createElement('div');
        card.className = 'card';
        if (index === currentIndex) card.classList.add('active');
        card.innerHTML = `
          <div class="card-content">
            <button class="bookmark-btn" onclick="toggleBookmark(${index}, event)">
              <i class="fas fa-${isBookmarked(concept.title) ? 'bookmark' : 'bookmark'}"></i>
            </button>
            <h2 class="title">${concept.title}</h2>
            <p class="explanation">${concept.explanation}</p>
            <div class="card-footer">
              <a href="https://www.google.com/search?q=${encodeURIComponent(concept.title)}" target="_blank">Learn More</a>
              <span class="progress" id="cardProgress"></span>
            </div>
          </div>
        `;
        container.appendChild(card);
      });
      updateProgress();
      animateCards();
      updateBookmarkPanel();
    }

    // ===============================
    // GSAP Animations for Smooth Card Appearance
    // ===============================
    function animateCards() {
      gsap.from(".card", {
        opacity: 0,
        y: 50,
        duration: 0.6,
        stagger: 0.2
      });
    }

    // ===============================
    // Handle Scroll for Active Card Styling
    // ===============================
    function handleScroll() {
      const cards = document.querySelectorAll('.card');
      cards.forEach((card, index) => {
        const rect = card.getBoundingClientRect();
        if (Math.abs(rect.top - 60) < window.innerHeight / 2) {
          card.classList.add('active');
          currentIndex = index;
          updateProgress();
        } else {
          card.classList.remove('active');
        }
      });
    }

    document.getElementById("container").addEventListener("scroll", handleScroll);

    // ===============================
    // Navigation Functions
    // ===============================
    document.getElementById("prevBtn").addEventListener("click", () => {
      if (currentIndex > 0) {
        currentIndex--;
        scrollToCard(currentIndex);
      }
    });

    document.getElementById("nextBtn").addEventListener("click", () => {
      if (currentIndex < filteredConcepts.length - 1) {
        currentIndex++;
        scrollToCard(currentIndex);
      }
    });

    function scrollToCard(index) {
      const cards = document.querySelectorAll('.card');
      if (cards[index]) {
        cards[index].scrollIntoView({ behavior: 'smooth' });
      }
    }

    // ===============================
    // Update Progress Indicator
    // ===============================
    function updateProgress() {
      const progressIndicator = document.getElementById('progressIndicator');
      progressIndicator.textContent = `Concept ${currentIndex + 1} of ${filteredConcepts.length}`;
    }

    // ===============================
    // Search Functionality
    // ===============================
    document.getElementById("searchInput").addEventListener("input", (e) => {
      const query = e.target.value.toLowerCase();
      filteredConcepts = conceptsData.filter(concept => 
        concept.title.toLowerCase().includes(query) || concept.explanation.toLowerCase().includes(query)
      );
      // Re-shuffle the filtered list randomly
      filteredConcepts = shuffle(filteredConcepts);
      currentIndex = 0;
      loadConcepts();
    });

    // ===============================
    // Bookmarking Functions
    // ===============================
    function isBookmarked(title) {
      return bookmarks.includes(title);
    }

    function toggleBookmark(index, event) {
      event.stopPropagation();
      const concept = filteredConcepts[index];
      if (isBookmarked(concept.title)) {
        bookmarks = bookmarks.filter(title => title !== concept.title);
      } else {
        bookmarks.push(concept.title);
      }
      localStorage.setItem('bookmarks', JSON.stringify(bookmarks));
      loadConcepts();
    }

    function updateBookmarkPanel() {
      const panel = document.getElementById('bookmarkPanel');
      const list = document.getElementById('bookmarkList');
      list.innerHTML = '';
      if (bookmarks.length === 0) {
        list.innerHTML = "<p style='text-align:center; color: var(--secondary-text)'>No bookmarks yet.</p>";
      } else {
        bookmarks.forEach(title => {
          const item = document.createElement('div');
          item.className = 'bookmark-item';
          item.textContent = title;
          item.onclick = () => {
            const idx = filteredConcepts.findIndex(concept => concept.title === title);
            if (idx !== -1) {
              currentIndex = idx;
              scrollToCard(currentIndex);
            }
          };
          list.appendChild(item);
        });
      }
    }

    document.getElementById("toggleBookmarks").addEventListener("click", () => {
      const panel = document.getElementById('bookmarkPanel');
      panel.classList.toggle('show');
    });

    // ===============================
    // Initialize the App on DOMContentLoaded
    // ===============================
    document.addEventListener("DOMContentLoaded", loadConcepts);
  </script>
</body>
</html>
